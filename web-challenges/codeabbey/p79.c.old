/* Need to implement Tarjan's strongly connected components algorithm.
 * https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm */
/* This may be a simpler algorithm to implement (using topological sort):
 * https://stackoverflow.com/questions/4168/graph-serialization/4577#4577 */
/* Another one that uses an adjacency matrix (what I have here):
 * https://1stprinciples.wordpress.com/2008/03/30/some-interesting-properties-of-adjacency-matrices/
 * just take map^3, then check for nonzero elements along the main diagonal.
 * Matrix method won't work because, despite the edges being undirected, the
 * problem doesn't want you to go backward, which is allowed by the matrix
 * method. This cannot be fixed by interpreting the edges as directed because
 * the problem doesn't specify the roads as directed, so a graph that contains
 * what is, formally speaking, a cycle may not be considered a cycle in the
 * problem. I think this needs to be scrapped and re-tried using a recursive
 * approach. Since the problem says there is at least one way between cities,
 * I should be able to pick any node and recursively travel through each node
 * in the graph, while maintaining a stack containing visited nodes. If I run
 * into a node that is already on the stack, then there must be a cycle
 * present. */
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_CITIES ('Z' - 'A' + 1)
#define MAX_LINE 1024
#define OFFSET(matrix, r, c) ((r)*matrix.width + (c))

enum boolean {FALSE, TRUE};

/* a vector is an array of elements with a certain length */
struct vector {
	unsigned short int length; /* length of the vector */
	double *element; /* array of elements in the vector */
};

/* a matrix is a 2-D structure with height and width */
struct matrix {
	unsigned short int height; /* height (m or number of rows) of matrix */
	unsigned short int width; /* width (n or number of columns) of matrix */
	double *element; /* 2-D array of elements in the matrix */
};

/* is_new_city: checks if the given city is in the cities array */
short int is_new_city(char cities[], char city) {
	unsigned short int i;
	for (i = 0; i < strlen(cities); i++) {
		if (cities[i] == city) {
			return i;
		}
	}
	return -1;
}

/* city_push: push a new city onto the cities array */
unsigned short int city_push(char cities[], char city) {
	unsigned short int index = strlen(cities);
	cities[index] = city;
	cities[index+1] = '\0';
	return index;
}

/* print_matrix: print a matrix with the associated cities */
void print_matrix(const struct matrix map) {
	unsigned short int i, j;
	printf(" ");
	for (i = 0; i < map.width; i++) {
		printf(" %c", i + 'A');
	}
	putchar('\n');
	for (i = 0; i < map.height; i++) {
		printf("%c ", i + 'A');
		for (j = 0; j < map.width; j++) {
			printf("%.0f ", map.element[OFFSET(map, i, j)]);
		}
		putchar('\n');
	}
}

void print_matrix_with_cities(char cities[], const struct matrix map) {
	unsigned short int i, j;
	unsigned short int cities_length = strlen(cities);
	printf(" ");
	for (i = 0; i < cities_length; i++) {
		printf(" %c", cities[i]);
	}
	putchar('\n');
	for (i = 0; i < cities_length; i++) {
		printf("%c ", cities[i]);
		for (j = 0; j < cities_length; j++) {
			printf("%.0f ", map.element[OFFSET(map, i, j)]);
		}
		putchar('\n');
	}
}

/* matrix_multiply: multiply a and b together, and return the result */
struct matrix matrix_multiply(const struct matrix a, const struct matrix b) {
	/* make sure the matrix inner dimensions agree */
	if (a.width != b.height) {
		fprintf(stderr, "matrix_multiply: matrix dimensions do not agree\n");
		exit(EXIT_FAILURE);
	}
	else {
		unsigned short int i;
		struct matrix c;
		/* c has the outer dimensions of a and b */
		c.height = a.height;
		c.width = b.width;
		/* allocate memory for the resulting matrix */
		c.element = malloc(c.height*c.width*sizeof *c.element);
		for (i = 0; i < c.height; i++) {
			unsigned short int j;
			for (j = 0; j < c.width; j++) {
				unsigned short int k;
				double sum;
				/* element c_ij is produced by taking the dot product of the
				 * ith row of a and the jth column of b */
				for (k = 0, sum = 0.0; k < a.width; k++) {
					sum +=
						a.element[OFFSET(a, i, k)]*b.element[OFFSET(b, k, j)];
				}
				c.element[OFFSET(c, i, j)] = sum;
			}
		}
		return c;
	}
}

/* trace: compute the trace of a matrix, which is the sum of the diagonal
 * elements */
double trace(const struct matrix matrix) {
	if (matrix.height != matrix.width) {
		fprintf(stderr, "trace: matrix must be square");
		exit(EXIT_FAILURE);
	}
	else {
		unsigned short int i;
		double sum;
		for (i = 0, sum = 0; i < matrix.height; i++) {
			sum += matrix.element[OFFSET(matrix, i, i)];
		}
		return sum;
	}
}

int main(void) {
	unsigned short int cases, i;
	struct matrix map, map_pow_n;
	map.height = MAX_CITIES;
	map.width = MAX_CITIES;
	map.element = malloc(map.height*map.width*sizeof *map.element);
	if (1 != scanf("%hu\n", &cases)) {
		fprintf(stderr, "error reading number of cases on line 1\n");
		exit(EXIT_FAILURE);
	}
	for (i = 0; i < cases; i++) {
		unsigned short int roads, j, k;
		char line[MAX_LINE], *line_p;
		char cities[MAX_CITIES];
		unsigned short int line_length;
		enum boolean cycle_boolean;
		struct matrix last_pow;
		cities[0] = '\0';
		for (j = 0; j < map.height; j++) {
			for (k = 0; k < map.width; k++) {
				map.element[OFFSET(map, j, k)] = 0;
			}
		}
		fgets(line, MAX_LINE, stdin);
		line_length = strlen(line);
		if (line[line_length-1] == '\n') {
			line[line_length-1] = '\0';
			line_length--;
		}
		roads = strtoul(line, &line_p, 10);
		for (j = 0; j < roads; j++, line_p++) {
			while (isspace(*line_p)) {
				line_p++;
			}
			if (line_p - line < line_length - 2) {
				unsigned short int left_city = *line_p;
				unsigned short int right_city;
				short int left_index, right_index;
				if ((left_index = is_new_city(cities, left_city)) == -1) {
					left_index = city_push(cities, left_city);
				}
				line_p += 2;
				right_city = *line_p;
				if ((right_index = is_new_city(cities, right_city)) == -1) {
					right_index = city_push(cities, right_city);
				}
				map.element[OFFSET(map, left_index, right_index)] = 1.0;
				/*map.element[OFFSET(map, right_index, left_index1)] = 1.0;*/
			}
			else {
				fprintf(stderr, "error reading road %hu on line %hu", j+1, i+2);
				exit(EXIT_FAILURE);
			}
		}
		print_matrix_with_cities(cities, map);
		cycle_boolean = FALSE;
		last_pow = map;
		last_pow.element =
			malloc(last_pow.height*last_pow.width*sizeof *last_pow.element);
		memcpy(last_pow.element, map.element,
				last_pow.height*last_pow.width*sizeof *last_pow.element);
		for (j = 2; j <= strlen(cities); j++) {
			map_pow_n = matrix_multiply(last_pow, map);
			print_matrix_with_cities(cities, map_pow_n);
			free(last_pow.element);
			/* ignore map^2 (j == 2) because this will always detect a cycle
			 * for undirected graphs (i.e. go to the next node, then come
			 * straight back). We therefore exclude j == 2. */
			if (trace(map_pow_n) != 0.0 && j != 2) {
				cycle_boolean = TRUE;
				break;
			}
			else {
				last_pow = map_pow_n;
			}
		}
		free(map_pow_n.element);
		printf((i == cases - 1) ? "%hu\n" : "%hu\n", cycle_boolean);
	}
	free(map.element);
	return 0;
}
